include llvm "../../runtime/runtime.ll";

import "print.uv";

external assume {
	struct tm {
		tm_sec: i32;   // seconds after the minute - [0, 60] including leap second
		tm_min: i32;   // minutes after the hour - [0, 59]
		tm_hour: i32;  // hours since midnight - [0, 23]
		tm_mday: i32;  // day of the month - [1, 31]
		tm_mon: i32;   // months since January - [0, 11]
		tm_year: i32;  // years since 1900
		tm_wday: i32;  // days since Sunday - [0, 6]
		tm_yday: i32;  // days since January 1 - [0, 365]
		tm_isdst: i32; // daylight savings time flag
	}

	fn time(store: @i64): i64;
	fn clock(): i64;

	fn gmtime_safe(utc: i64): tm;
	fn localtime_safe(utc: i64): tm;
}



struct Date {
	day: int;     // Date [1, 31]
	month: int;   // Month [0, 7]
	year: int;    // Year

	days: int;    // Day of the year [0, 365]
	weekDay: int; // Day of the week [0, 6]
}

struct Time {
	seconds: int;
	minutes: int;
	hours: int;

	dayLightSavings: bool;
}

struct DateTime {
	date: Date;
	time: Time;
}


fn Now(): i64 {
	let t: i64 = 0;
	time(@t);

	return t;
}

fn Clock(): i64 {
	return clock();
}


fn GetLocalDateTime(unixTime: i64): DateTime {
	return tm_to_DateTime( localtime_safe(unixTime) );
}
fn GetUTCDateTime(unixTime: i64): DateTime {
	return tm_to_DateTime( gmtime_safe(unixTime) );
}


fn tm_to_DateTime(info: tm): DateTime {
	let out = Blank#[DateTime]();

	out.time.hours  = cast#[i64](info.tm_hour);
	out.time.minutes = cast#[i64](info.tm_min);
	out.time.seconds = cast#[i64](info.tm_sec);

	out.date.day   = cast#[i64](info.tm_mday);
	out.date.month = cast#[i64](info.tm_mon) + 1;
	out.date.year  = cast#[i64](info.tm_year) + 1900;
	out.date.weekDay = cast#[i64](info.tm_wday);
	out.date.days    = cast#[i64](info.tm_yday);
	if (cast#[i64](info.tm_isdst) == 1) {
		out.time.dayLightSavings = true;
	} else {
		out.time.dayLightSavings = false;
	}

	return out;
}